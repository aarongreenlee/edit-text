<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <style>
            /* Hide empty links*/
            a[href="#.html"] { opacity: 0.5; pointer-events: none; }

            /* svgbob monospace */
            svg.bob { font-family: Monaco, monospace; display: block; margin: 1.6em auto; padding: 2em 3em; }
            svg.bob text { transform: translateX(-2px); }

            p > img:first-child, svg.bob { display: block; }
            table, table th, table td { border-collapse: collapse; border: 1px solid #bbb; }
            table th { padding: 0.2em 1.5em }

            /* header spacing */
            h2, h3 { margin-top: 1.6em; }

            main { line-height: 1.5; }
        </style>

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="intro.html"><strong aria-hidden="true">1.</strong> edit-text</a></li><li><ol class="section"><li><a href="getting-started.html"><strong aria-hidden="true">1.1.</strong> Getting Started</a></li></ol></li><li><a href="development.html"><strong aria-hidden="true">2.</strong> Development</a></li><li><ol class="section"><li><a href="intro-system.html"><strong aria-hidden="true">2.1.</strong> System Overview</a></li><li><a href="intro-x.html"><strong aria-hidden="true">2.2.</strong> Build with ./tools</a></li><li><a href="intro-testing.html"><strong aria-hidden="true">2.3.</strong> Tests</a></li><li><ol class="section"><li><a href="#.html"><strong aria-hidden="true">2.3.1.</strong> Writing an integration test</a></li></ol></li></ol></li><li><a href="editor-basics.html"><strong aria-hidden="true">3.</strong> Editor Basics</a></li><li><ol class="section"><li><a href="working-with-documents.html"><strong aria-hidden="true">3.1.</strong> Documents</a></li><li><a href="working-with-operations.html"><strong aria-hidden="true">3.2.</strong> Operations</a></li><li><a href="rtf-ot.html"><strong aria-hidden="true">3.3.</strong> Operational Transform</a></li></ol></li><li><a href="rtf.html"><strong aria-hidden="true">4.</strong> Rich Text</a></li><li><ol class="section"><li><a href="markdown.html"><strong aria-hidden="true">4.1.</strong> Markdown</a></li><li><a href="diary-carets.html"><strong aria-hidden="true">4.2.</strong> Carets</a></li></ol></li><li><a href="server.html"><strong aria-hidden="true">5.</strong> Server</a></li><li><ol class="section"><li><a href="server-apis.html"><strong aria-hidden="true">5.1.</strong> HTTP APIs</a></li><li><a href="storage.html"><strong aria-hidden="true">5.2.</strong> Storage</a></li></ol></li><li><a href="frontend.html"><strong aria-hidden="true">6.</strong> Frontend</a></li><li><ol class="section"><li><a href="editor-component.html"><strong aria-hidden="true">6.1.</strong> Editor Component</a></li><li><a href="webassembly-interface.html"><strong aria-hidden="true">6.2.</strong> WebAssembly Interface</a></li></ol></li><li><a href="deploying.html"><strong aria-hidden="true">7.</strong> Deploying</a></li><li><ol class="section"><li><a href="edit-server-binary.html"><strong aria-hidden="true">7.1.</strong> Running as a binary</a></li><li><a href="dokku.html"><strong aria-hidden="true">7.2.</strong> Dokku</a></li><li><a href="#.html"><strong aria-hidden="true">7.3.</strong> Hosted Sandbox</a></li><li><a href="#.html"><strong aria-hidden="true">7.4.</strong> npm module</a></li></ol></li><li><a href="appendix.html"><strong aria-hidden="true">8.</strong> Appendix</a></li><li><ol class="section"><li><a href="diary-delall.html"><strong aria-hidden="true">8.1.</strong> Delall Hack</a></li><li><a href="glossary.html"><strong aria-hidden="true">8.2.</strong> Glossary</a></li></ol></li></ol>
            <div class="chapter">
                <div>Crate documentation:</div>
                <ul class="section" style="margin-top: -0.25em">
                    <li><a href="/crates/oatie/">oatie</a></li>
                    <li><a href="/crates/edit_common/">edit-common</a></li>
                    <li><a href="/crates/edit_client/">edit-client</a></li>
                    <li><a href="/crates/edit_server/">edit-server</a></li>
                </ul>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                            <a id="edit-toggle" class="icon-button" title="Edit page" aria-label="Edit page" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list" href="https://github.com/tcr/edit-text/edit/master/docs/src/print.md?message=Updating docs for print.md" style="text-decoration: none">
                                <i class="fa fa-pencil"></i> EDIT
                            </a>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#edit-text" id="edit-text"><h1>edit-text</h1></a>
<p>edit-text is a Markdown-compatible document editor that supports collaborative editing. Its server and client are written in Rust, and its frontend uses TypeScript and WebAssembly.</p>
<div>
<img src="https://user-images.githubusercontent.com/80639/42796912-9f2ae852-895a-11e8-9aae-9dede91296bf.png">
</div>
<p>For installation instructions, please read <a href="getting-started.html"><strong>Getting Started</strong></a>.</p>
<a class="header" href="#getting-started" id="getting-started"><h1>Getting Started</h1></a>
<a class="header" href="#requirements" id="requirements"><h2>Requirements</h2></a>
<p><strong>Installing rustup:</strong> <code>edit-text</code> is written in Rust, and so you will need a
Rust compiler in order to serve the application. Rust may be installed using
your system package manager, but the preferred way to download and install Rust
is through the <a href="http://rustup.rs/"><code>rustup</code> toolchain</a> available at rustup.rs.
To check if you have <code>rustup</code> installed, you can run the following command:</p>
<pre><code>$ rustup show active-toolchain
nightly-2018-09-25-x86_64-apple-darwin  # for example
</code></pre>
<p>This command should print a rust version that is equivalent to the contents of
the <code>./rust-toolchain</code> file. This is the version of the nightly Rust compiler
the project currently depends on. This file is updated periodically; <code>rustup</code>
will automatically manage downloading and using the correct compiler version for
you.</p>
<p><strong>Installing Node.js:</strong> To build the frontend you will need to install something
called <a href="http://nodejs.org/">Node.js</a> and <a href="http://yarnpkg.com">Yarn</a>. To install
Node.js, see <a href="https://nodejs.org/en/download/package-manager/">installation instructions for your
OS</a>. To check if you have a
recent version of Node.js installed, see if the output of this command is <code>&gt;= v6.0.0</code>:</p>
<pre><code>$ node -v
v10.12.0  # for example
</code></pre>
<p>The frontend is written partly in TypeScript, and the build tool uses Yarn to
install and manage its JavaScript package dependencies. To install yarn, follow
the <a href="https://yarnpkg.com/en/docs/install#mac-stable">installation instructions for your
OS</a> or just run <code>npm i -g yarn</code>.
To see if Yarn is installed and available:</p>
<pre><code>$ yarn -v
v1.10.1  # for example
</code></pre>
<a class="header" href="#usage" id="usage"><h2>Usage</h2></a>
<p>Clone the repository from Github:</p>
<pre><code>git clone https://github.com/tcr/edit-text
</code></pre>
<p>Build commands are executed using the <code>./tools</code> script. You can rebuild
individual edit-text components with <code>./tools server-build</code>, <code>./tools frontend-build</code>, etc. Run <code>./tools help</code> for more information.</p>
<a class="header" href="#run-the-server" id="run-the-server"><h3>Run the server</h3></a>
<p>The production configuration of edit-text is a long-running server process, and
one or many WebAssembly + TypeScript clients running in the browser that connect
to it.</p>
<p>You can build the WebAssembly client as well as the frontend webpack module
using the following command:</p>
<pre><code class="language-sh">./tools frontend-build
</code></pre>
<p>This cross-compiles all frontend code and pulls in the compiled WebAssembly
binary, using <a href="https://github.com/rustwasm/wasm-bindgen">wasm-bindgen</a> to talk
to the frontend.</p>
<p>In your terminal session, you can then run this command to start the server:</p>
<pre><code>./tools server
</code></pre>
<p>Now open <a href="http://localhost:8000/">http://localhost:8000/</a> and you are brought to a welcome page to start
editing text!</p>
<a class="header" href="#development-workflow" id="development-workflow"><h3>Development Workflow</h3></a>
<p>A simple development pattern is to launch <code>./tools server</code> in one window, and
to watch and recompile frontend code whenever it's modified with this command in
another window:</p>
<pre><code class="language-sh">./tools frontend-watch
</code></pre>
<p>This command watches the edit-frontend directory and continuously builds its
after each change. The frontend will periodically display a notification if a
newer version of the client code has been compiled.</p>
<p>After you make changes to <code>edit-server/</code>, <code>edit-common/</code>, or <code>oatie/</code>, you
should kill and re-run the <code>./tools server</code> command to rebuild and launch it.
The <code>frontend-watch</code> command will automatically rebuild code that it depends
on for you.</p>
<a class="header" href="#development" id="development"><h1>Development</h1></a>
<p>edit-text uses a build system written in Rust, <code>./tools</code>, which is a basic
wrapper over <code>cargo</code> and <code>npm</code> commands and other essential project functionality.
This is used to invoke tests as well as launch the edit-text server.</p>
<ol>
<li><a href="intro-system.html">System Overview</a></li>
<li><a href="intro-x.html">Build with ./tools</a></li>
<li><a href="intro-testing.html">Tests</a></li>
</ol>
<a class="header" href="#system-overview" id="system-overview"><h1>System Overview</h1></a>
<p>edit-text is built from the ground up as a collaborative text editor. It uses
operational transform to merge updates from multiple clients, so it requires a
synchronizing server. The server is also in charge of storing page content, so
that every page can be shared via its URL.</p>
<p>There are four components in the system:</p>
<ul>
<li>
<p>The <strong>Server</strong>, which serves HTTP content, a GraphQL endpoint for performing
page-level commands, and a WebSocket endpoint for synchronizing document
content.</p>
</li>
<li>
<p>The <strong>Client</strong>, which can connect to a server and synchronize its document
content. It sends client-side modifications (in the form of operations) to the
server, and receives updated content (in the form of operations) from the server
after any client submits an update.</p>
</li>
<li>
<p>The <strong>Controller</strong>, which receives UI-level event updates from the frontend
and converts it into operations on the client document.</p>
</li>
<li>
<p>The <strong>Frontend</strong>, which is the editor UI. The current document is rendered
as a component inside the frontend, and interactions with this component are
forwarded to the controller. The frontend also manages the toolbar,
notifications, and dialog boxes.</p>
</li>
</ul>
<p>Each of these four components can be controlled by their <strong>commands</strong>, defined
in <code>commands.rs</code>, effectively providing an asynchronous API for each component
in the system.</p>
<p>Here is a diagram representing communication between the Server, Client,
Controller, and Frontend:</p>
<p><svg class="bob" font-family="arial" font-size="14" height="208" width="608" xmlns="http://www.w3.org/2000/svg"> <defs> <marker id="triangle" markerHeight="8" markerWidth="8" orient="auto" refX="4" refY="2" viewBox="0 0 8 4"> <polygon class="fg_fill" points="0,0 0,4 8,2 0,0"/> </marker> <marker id="clear_triangle" markerHeight="10" markerWidth="10" orient="auto" refX="1" refY="7" viewBox="0 0 20 14"> <polygon class="bg_fill" points="2,2 2,12 18,7 2,2"/> </marker> <marker id="circle" markerHeight="5" markerWidth="5" orient="auto" refX="10" refY="10" viewBox="0 0 20 20"> <circle class="fg_fill" cx="10" cy="10" r="8"/> </marker> <marker id="square" markerHeight="5" markerWidth="5" orient="auto" refX="10" refY="10" viewBox="0 0 20 20"> <rect class="fg_fill" height="20" width="20" x="0" y="0"/> </marker> <marker id="open_circle" markerHeight="10" markerWidth="10" orient="auto" refX="10" refY="10" viewBox="0 0 20 20"> <circle class="bg_fill" cx="10" cy="10" r="4"/> </marker> <marker id="big_open_circle" markerHeight="20" markerWidth="20" orient="auto" refX="20" refY="20" viewBox="0 0 40 40"> <circle class="bg_fill" cx="20" cy="20" r="6"/> </marker> </defs> <style type="text/css">  rect.backdrop {     fill: white; } text{     fill: black; }  circle {     fill: none;     stroke: black;     stroke-width: 2; }  line {     stroke: black;     stroke-width: 2;     stroke-opacity: 1;     fill-opacity: 1;     stroke-linecap: round;     stroke-linejoin: miter; }  path {     fill: none;     stroke: black;     stroke-width: 2;     stroke-opacity: 1;     fill-opacity: 1;     stroke-linecap: round;     stroke-linejoin: miter; }  line.dashed {     stroke-dasharray: 5; }  .fg_fill {     fill: black; }   .bg_fill {     fill: white;     stroke: black;     stroke-width: 2; }  tspan.head{     fill: none;     stroke: none; }      </style> <rect class="backdrop" height="208" width="608" x="0" y="0"/> <g> <line x1="4" x2="4" y1="8" y2="72"/> <line x1="4" x2="92" y1="8" y2="8"/> <line x1="4" x2="92" y1="72" y2="72"/> <line x1="92" x2="92" y1="8" y2="72"/> </g> <g> <line marker-end="url(#triangle)" x1="112" x2="108" y1="40" y2="40"/> <line x1="112" x2="132" y1="40" y2="40"/> <line x1="132" x2="132" y1="40" y2="200"/> <line marker-end="url(#triangle)" x1="132" x2="164" y1="40" y2="40"/> <line marker-end="url(#triangle)" x1="132" x2="180" y1="200" y2="200"/> </g> <g> <line marker-end="url(#triangle)" x1="132" x2="180" y1="136" y2="136"/> </g> <g> <line marker-end="url(#triangle)" x1="132" x2="180" y1="168" y2="168"/> </g> <g> <line x1="172" x2="172" y1="8" y2="72"/> <line x1="172" x2="292" y1="8" y2="8"/> <line x1="172" x2="292" y1="72" y2="72"/> <line x1="292" x2="292" y1="8" y2="72"/> <line x1="292" x2="412" y1="8" y2="8"/> <line x1="292" x2="412" y1="72" y2="72"/> <line x1="412" x2="412" y1="8" y2="72"/> </g> <g> <line marker-end="url(#triangle)" x1="424" x2="420" y1="40" y2="40"/> <line marker-end="url(#triangle)" x1="424" x2="476" y1="40" y2="40"/> </g> <g> <line x1="484" x2="484" y1="8" y2="72"/> <line x1="484" x2="604" y1="8" y2="8"/> <line x1="484" x2="604" y1="72" y2="72"/> <line x1="604" x2="604" y1="8" y2="72"/> </g> <g> <text x="25" y="44"> Server </text> </g> <g> <text x="25" y="92"> (Rust) </text> </g> <g> <text x="193" y="140"> Client </text> </g> <g> <text x="193" y="172"> Client </text> </g> <g> <text x="193" y="204"> ... </text> </g> <g> <text x="201" y="44"> Client </text> </g> <g> <text x="217" y="92"> (Rust </text> </g> <g> <text x="249" y="140"> B </text> </g> <g> <text x="249" y="172"> C </text> </g> <g> <text x="257" y="44"> A </text> </g> <g> <text x="265" y="92"> + </text> </g> <g> <text x="281" y="92"> WebAssembly) </text> </g> <g> <text x="313" y="44"> Controller </text> </g> <g> <text x="497" y="92"> (TypeScript) </text> </g> <g> <text x="513" y="44"> Frontend </text> </g> </svg></p>
<p>Notice that <strong>Client</strong> and <strong>Controller</strong> are part of the same component. This is useful
from an API perspective: commands that are addressed to the client will always
originate from the server, and commands addressed to the Controller will always
originate from the frontend. On the implementation level, however, Client and
Controller are the same process.</p>
<p>The server is a command-line program called <code>edit-server</code>. In release mode, it
bundles all client-side code and can be uploaded to a server to run the program
directly.</p>
<p>The edit-text client is written in Rust and can be run both in the browser (to
power the editor) or from the command line (for tools like the client proxy, and client replay).
If you use edit-text in its normal configuration, the Client, Controller, and
Frontend all run in your browser as WebAssembly and JavaScript. In proxy mode,
the Client and Controller run as a command line program.</p>
<p>The Frontend is written in TypeScript.</p>
<a class="header" href="#cratemodule-overview" id="cratemodule-overview"><h2>Crate/Module overview</h2></a>
<p>The top-level crates/modules are these:</p>
<ul>
<li><code>oatie/</code> is the operational transform library</li>
<li><code>edit-common/</code> contains code shared by all edit-* crates</li>
<li><code>edit-client/</code> contains the Client and Controller</li>
<li><code>edit-server/</code> contains the Server binary</li>
<li><code>edit-frontend/</code> contains the Frontend code as a Node module compiled with webpack</li>
</ul>
<a class="header" href="#build-with-tools" id="build-with-tools"><h1>Build with ./tools</h1></a>
<p>edit-text has a custom build script written in Rust that you invoke by running
<code>./tools</code> in the project root directory. This is a basic wrapper over <code>cargo</code>
and <code>npm</code> commands and other essential project functionality, and provides an
easy way to launch the edit-text server and compile the frontend JavaScript
bundle.</p>
<p>To see a list of build commands, open the project directory in your terminal
and run the following command:</p>
<pre><code>./tools help
</code></pre>
<p>NOTE: If you are on Windows running in <code>cmd.exe</code>, you will need to
invoke the build tool with <code>.\tools</code> instead. Please substitute <code>./tools</code> with
<code>.\tools</code> throughout this guide.</p>
<a class="header" href="#building-the-server" id="building-the-server"><h2>Building the Server</h2></a>
<p>To build the edit-text server:</p>
<pre><code class="language-sh">./tools server-build
</code></pre>
<p>To build and launch the server on HTTP port <code>8000</code>:</p>
<pre><code class="language-sh">./tools server
</code></pre>
<a class="header" href="#building-the-frontend" id="building-the-frontend"><h2>Building the Frontend</h2></a>
<p>The frontend is all the JavaScript code that runs in the browser, and optionally including the WASM build system. To build the frontend, run this from the root directory:</p>
<pre><code class="language-sh">./tools frontend-build
</code></pre>
<p>If you want to launch a long-lived script to build the frontend and rebuild each time a frontend file changes:</p>
<pre><code class="language-sh">./tools frontend-watch
</code></pre>
<a class="header" href="#just-compiling-the-webassembly-client" id="just-compiling-the-webassembly-client"><h3>Just compiling the WebAssembly client</h3></a>
<p>Building <em>just</em> the frontend WebAssembly component generated from <code>edit-client</code> can be done using this command:</p>
<pre><code class="language-sh">./tools wasm-build
</code></pre>
<p>This will compile the wasm bundle and save it to <code>edit-frontend/src/bindgen</code>, which will be linked with the frontend code bundle. WASM is automatically compiled during the <code>frontend-build</code> or <code>frontend-watch</code> steps.</p>
<a class="header" href="#testing" id="testing"><h2>Testing</h2></a>
<p>This command will run all unit tests as well as integration tests (end-to-end testing using a machine-controlled browser).</p>
<pre><code class="language-sh">./tools test
</code></pre>
<p>If you're in a continuous integration (CI) environment, you can perform all relevant test steps for your branch by running:</p>
<pre><code class="language-sh">./tool ci
</code></pre>
<a class="header" href="#client-proxy" id="client-proxy"><h2>Client Proxy</h2></a>
<p>If you are testing changes to the <code>edit-client</code> library, you have the option of choosing between running client code in the browser (via WebAssembly) or running it in a local Rust process, having all commands proxied through websockets.</p>
<pre><code class="language-sh">./tools client-proxy
</code></pre>
<a class="header" href="#building-the-book" id="building-the-book"><h2>Building the book</h2></a>
<p>You can build the book with the book-build command:</p>
<pre><code class="language-sh">./tools book-build
</code></pre>
<p>Or watch for all changes as they are being made with book-watch.</p>
<pre><code class="language-sh">./tools book-watch
</code></pre>
<p>By navigating to <a href="http://localhost:3000/">http://localhost:3000/</a>, you'll see the page refresh automatically as you edit markdown files under <code>docs-src/</code>.</p>
<a class="header" href="#running-edit-text-with-a-client-in-proxy-mode-for-debugging" id="running-edit-text-with-a-client-in-proxy-mode-for-debugging"><h2>Running edit-text with a client in proxy mode (for debugging)</h2></a>
<p><strong>NOTE:</strong> You can skip this section if you are just getting started.</p>
<p>Debugging WebAssembly code is harder (in most ways) than debugging a local Rust binary. edit-text supports running the client as an independent &quot;proxy&quot;. An edit-text server running in one terminal connects to a client proxy running in another terminal, and communicates with frontend code running in the browser (TypeScript) over WebSockets. This client proxy is all code that would normally be cross-compiled to WebAssembly, but runs locally in your terminal and supports the same backtrace and debugging support as a local binary.</p>
<p>You'll need two terminal sessions to run in this mode. First, start the server, and specify that you want to connect to a client proxy using <code>--client-proxy</code>. Without this argument, the server will expect server connections from WebAssembly instead.</p>
<pre><code>./tools server --client-proxy [--release]
</code></pre>
<p>In another terminal session, you can start the proxy. (It's recommended you compile in release mode, as client code is much slower in debug mode.)</p>
<pre><code>./tools client-proxy [--release]
</code></pre>
<p>Then you can open http://localhost:8000/ as before in your browser, and monitor the <code>client-proxy</code> terminal for status of the clients that your browser is connected to.</p>
<p>You will see any failures appear in the client-proxy code that would appear in the browser console when in WASM mode. If you encounter a panic or fatal error, this &quot;proxy&quot; mechanism of debugging usually gives much more information about where the error originated. Note that aside from running as a binary, there should be no differences in behavior between the client-proxy and the client in Webassembly.</p>
<a class="header" href="#testing-1" id="testing-1"><h1>Testing</h1></a>
<p>There are two types of tests, integration tests and unit tests.</p>
<a class="header" href="#unit-tests" id="unit-tests"><h2>Unit Tests</h2></a>
<p>To run unit tests, run <code>./tools test unit</code>.</p>
<a class="header" href="#integration-tests" id="integration-tests"><h2>Integration Tests</h2></a>
<p>Integration tests use a &quot;headless&quot; browser to run</p>
<p>Run <code>./tools test integration</code> to run the test suite with integrated tests. Run <code>./tools test all</code> to run unit tests and integration tests.</p>
<p>This runs simulated tests using headless browsers running concurrent editing operation. You should install a WebDriver implementation such as  <code>geckodriver</code>:</p>
<ul>
<li>macOS: <code>brew install geckodriver</code></li>
<li>Ubuntu: <code>npm install -g geckodriver</code></li>
<li>Windows: <code>choco install selenium-gecko-driver</code></li>
</ul>
<!--
<a class="header" href="#oatie-testing" id="oatie-testing"><h2>Oatie testing</h2></a>
<ul>
<li>Transform test (oatie/in, transform_test.sh)</li>
<li>Unit tests</li>
</ul>
<p>Missing:</p>
<ul>
<li>Virtual monkey (on random schemas?)</li>
</ul>
<a class="header" href="#edit-text-testing" id="edit-text-testing"><h2>edit-text testing</h2></a>
<ul>
<li></li>
<li><code>geckodriver</code> integrated test (./tools test)</li>
</ul>
<p>Manual:</p>
<ul>
<li>Multi Monkey (/$/multi.html)</li>
<li>Virtual Monkey (uh....)</li>
</ul>
<p>Missing:</p>
<ul>
<li>Unit tests</li>
</ul>
<p>--&gt;</p>
<a class="header" href="#appendix" id="appendix"><h1>Appendix</h1></a>
<a class="header" href="#editor-basics" id="editor-basics"><h1>Editor Basics</h1></a>
<p>This section describes the basics of how editors are stored and modified.
The content of the editor is a &quot;document&quot; composed of text and
groups (which can contain other text or groups). Operations are data types that
can modify the document by adding or deleting content. These operations are
composable, and also can occur concurrently—conflicts are resolved with the
operational transform algorithm.</p>
<ol>
<li><a href="working-with-documents.html">Documents</a></li>
<li><a href="working-with-operations.html">Operations</a></li>
<li><a href="rtf-ot.html">Operational Transform</a></li>
</ol>
<a class="header" href="#documents" id="documents"><h1>Documents</h1></a>
<p>The contents of a page is stored as a <strong>Document</strong> object. For example, the following &quot;Hello world!&quot; document:</p>
<p><img width="1189" alt="image" src="https://user-images.githubusercontent.com/80639/50059231-1737f500-0152-11e9-8704-d133d6b19e66.png"></p>
<p>May be created and manipulated in Rust:</p>
<pre><code class="language-rust noplaypen">let document = doc_span![
    DocGroup({&quot;tag&quot;: &quot;h1&quot;}, [&quot;Hello world!&quot;]),
    DocGroup({&quot;tag&quot;: &quot;p&quot;}, [&quot;This is a document.&quot;]),
];

// Convert this document to Markdown.
let markdown = edit_common::markdown::doc_to_markdown(&amp;document)?;
</code></pre>
<a class="header" href="#text-and-groups" id="text-and-groups"><h2>Text and Groups</h2></a>
<p>Documents are composed of <strong>text</strong> and <strong>groups</strong>. Text is a unicode string modeled by the <code>DocString</code> type. Groups are similar to HTML elements, having a set of &quot;attributes&quot; and then a vector of children which can be either text or other groups.</p>
<p>In Rust, <code>enum DocElement</code> models these two types:</p>
<pre><code class="language-rust noplaypen">type DocSpan = Vec&lt;DocElement&gt;;

type Attrs = HashMap&lt;String, String&gt;;

enum DocElement {
    DocChars(DocString),
    DocGroup(Attrs, DocSpan),
}
</code></pre>
<p>You can use the <code>oatie::macros::doc_span!</code> macro to conveniently create <code>DocSpan</code> objects:</p>
<pre><code class="language-rust noplaypen">doc_span![
    DocGroup({&quot;tag&quot;: &quot;h1&quot;}, [&quot;Title&quot;]),
    DocGroup({&quot;tag&quot;: &quot;bullet&quot;}, [
        DocGroup({&quot;tag&quot;: &quot;p&quot;}, [&quot;Groups can be nested.&quot;]),
        DocGroup({&quot;tag&quot;: &quot;p&quot;}, [&quot;With multiple elements.&quot;]),
    ]),
]
</code></pre>
<a class="header" href="#documents-and-operations" id="documents-and-operations"><h2>Documents and Operations</h2></a>
<p>Documents can <a href="working-with-operations.html">have operations performed on them</a> to result in a new, modified document.</p>
<a class="header" href="#schema" id="schema"><h2>Schema</h2></a>
<p>Documents have no enforced structure other than being a collection of text and groups. To define which types in a document are valid and what they are allowed to contain, the <code>oatie::schema::RtfSchema</code> defines which groups can contain what other groups, which can contain text content, and which can be found in the root. See <code>oatie::validate::validate_doc_span</code> for how to validate a document tree.</p>
<a class="header" href="#operations" id="operations"><h1>Operations</h1></a>
<p>Operations are sequences of steps that when applied to a document, modifies the document by adding or removing content. Operations are
broken down into two stages: deleting content, then adding content. This pair of &quot;delete&quot; and &quot;add&quot; steps makes up an operation, which is performed atomically on a document, ensuring that the result is always valid.</p>
<p>Operations can be &quot;applied&quot; to a document, producing a new document:</p>
<pre><code class="language-rust noplaypen">let updated_doc = Op::apply(&amp;doc, &amp;operation);
</code></pre>
<p>When applying multiple operation pairs in a row, you can also &quot;compose&quot; them to
produce a single operation that would produce the same result:</p>
<pre><code class="language-rust noplaypen">let updated_doc_1 = Op::apply(&amp;doc, &amp;operation_1);
let updated_doc_2 = Op::apply(&amp;updated_doc_1, &amp;operation_2);

// Same result
let updated_doc_2 = Op::apply(
    &amp;doc,
    &amp;Op::compose(&amp;operation_1, &amp;operation_2), // Composed operation
);
</code></pre>
<p>You can also transform two concurrent operation; see the section on <a href="rtf-ot.html">operational transform</a>.</p>
<a class="header" href="#example-combining-two-groups" id="example-combining-two-groups"><h2>Example: Combining Two Groups</h2></a>
<p>Let's start with a simple document composed of a title and a paragraph. The document
looks like the following in Markdown:</p>
<pre><code class="language-markdown"># Title

Body
</code></pre>
<p>And would have the following document representation:</p>
<pre><code class="language-rust noplaypen">let doc = doc_span![
    DocGroup({&quot;tag&quot;: &quot;h1&quot;}, [DocChars(&quot;Title&quot;)]),
    DocGroup({&quot;tag&quot;: &quot;p&quot;}, [DocChars(&quot;Body&quot;)]),
];
</code></pre>
<p>Imagine the user starts editing. The user places their caret to the left of the word &quot;Body&quot;, then hits backspace. What will happen is that the paragraph containing &quot;Body&quot; and the header containing the text &quot;Title&quot; will become combined into one header with the text &quot;TitleBody&quot;.</p>
<p>There are a few ways to can imagine combining these two elements. The way in which edit-text implements this is by first deleting
the current and preceding blocks while preserving their content, then creating a new element
which spans the content of both blocks.</p>
<p>First, we would delete each block group:</p>
<pre><code class="language-rust noplaypen">let deletion = del_span![
    DelGroup([DelSkip(5)]), // Five characters in &quot;Title&quot;
    DelGroup([DelSkip(4)]), // Four characters in &quot;Body&quot;
];

assert_eq!(
    Op::apply_deletion(&amp;doc, &amp;deletion),
    doc_span![DocChars(&quot;TitleBody&quot;)],
);
</code></pre>
<p>The result is just the characters &quot;TitleBody&quot;. In edit-text, you are not allowed to have top-level textual content that is not contained inside of a group. So in order to produce a valid document, we now have to wrap the contents of both groups inside of a new group:</p>
<pre><code class="language-rust noplaypen">let addition = del_span![
    AddGroup({&quot;tag&quot;: &quot;h1&quot;}, [
        AddSkip(9) // Nine characters in &quot;Titlebody&quot;
    ])
];

assert_eq!(
    Op::apply_addition(&amp;Op::apply_deletion(&amp;doc, &amp;deletion), &amp;addition),
    doc_span![
        DocGroup({&quot;tag&quot;: &quot;h1&quot;}, [DocChars(&quot;TitleBody&quot;)]),
    ];
);
</code></pre>
<p>A deletion followed by an addition is common enough in edit-text that you can work with it as a single datatype. The method <code>Op::apply</code> takes a document and a <code>&amp;(DelSpan, AddSpan)</code> type, and returns a modified document.</p>
<pre><code class="language-rust noplaypen">type Op = (DelSpan, AddSpan);

let valid_op: Op = (
    del_span![
        DelGroup([DelSkip(5)]),
        DelGroup([DelSkip(4)]),
    ],
    add_span![
        AddGroup({&quot;tag&quot;: &quot;h1&quot;}, [AddSkip(9)]),
    ],
);

assert_eq!(
    Op::apply(&amp;doc, &amp;valid_op),
    doc_span![
        DocGroup({&quot;tag&quot;: &quot;h1&quot;}, [DocChars(&quot;TitleBody&quot;)]),
    ];
);
</code></pre>
<a class="header" href="#constaints" id="constaints"><h2>Constaints</h2></a>
<p>Applying operations can fail. Usually, an operation is written to modify a known
document state, and applying that operation to the document it was intended for
should never fail.</p>
<p>NOTE: At the moment, if your apply an operation improperly to document and it
fails, it will likely panic!() rather than returning an Error object.</p>
<a class="header" href="#deletion-and-addition-elements" id="deletion-and-addition-elements"><h2>Deletion and Addition Elements</h2></a>
<p>These are all the steps a Deletion or Addition can perform.</p>
<pre><code class="language-rust noplaypen">enum DelElement {
    /// ...
    DelSkip(usize),
    DelWithGroup(DelSpan),
    DelChars(usize),
    DelGroup(DelSpan),
}
</code></pre>
<pre><code class="language-rust noplaypen">enum AddElement {
    AddSkip(usize),
    AddWithGroup(AddSpan),
    AddChars(DocString),
    AddGroup(Attrs, AddSpan),
}
</code></pre>
<a class="header" href="#operational-transform" id="operational-transform"><h1>Operational Transform</h1></a>
<p>When two clients A and B make an operation concurrently, one way to get them back in sync is to determine what would operation B look like if operation A had happened first, and vice versa. If we can guarantee that this result on both clients produce the same output, meaning if we can guarantee the following (where &quot;:&quot; means &quot;composed with&quot;):</p>
<pre><code> operation A : (operation B as if A had happened first)

        the above composition is equivalent to

 operation B : (operation A as if B had happened first)
</code></pre>
<p>Then we can guarantee both clients, which had different operations occur to their documents before this moment in time, can get back in sync. The algorithm used by <code>oatie</code> guarantees this operation will be commutative, which is makes other properties of this system simpler.</p>
<a class="header" href="#rules-for-transform" id="rules-for-transform"><h2>Rules for Transform</h2></a>
<p>Operational transform is commutative, which is to say that a result of transforming A × B should result in A' and B', and the property A composed with A' == B composed with B'. Or put another way, the transform function when given two operations will return two subsequent operations to bring both clients into an identical document state.</p>
<p>Starting with a simple example, what happens when two documents type the same character simultaneously:</p>
<pre><code>doc:       ed

          bed
client A: ^

          red
client B: ^
</code></pre>
<p>We can determine a hueristic, say, that when transforming we always know client A goes first and B second, and come up with the transformed operations:</p>
<pre><code>           bred
client A':  ^

           bred
client B': ^
</code></pre>
<p>Now both clients are synchronized again, and we can repeat this at any time as long as we use a stable client ordering. If we look at deleting characters, we actually discover we don't even need an order:</p>
<pre><code>doc:      creditor

            editor
client A: XX

          credit
client B:       XX

new doc:   edit
</code></pre>
<p>Deletions, as we'll call them, are commutative, and the result of transforming them should update both clients to have deleted their union. This holds true in even more complex scenarios.</p>
<p>A harder consideration is when we introduce groups, which are similar to HTML elements. <code>oatie</code> doesn't operate on HTML tags, but acts more like the DOM: groups are strictly nested and can only contain text or other groups. Each group has a &quot;tag&quot; (like an HTML tag), but also can contain other attributes (for example, each user's cursor contains the attribute of its originating client).</p>
<p>Transforming two operations which operate on groups in distinct ways offers some difficulty.</p>
<a class="header" href="#transform-in-depth" id="transform-in-depth"><h2>Transform In Depth</h2></a>
<p><strong>NOTE: The remainder of this document is not necessary for developing on edit-text.
If you're interested in more about how the transform step works, read on.</strong></p>
<a class="header" href="#race-condition" id="race-condition"><h3>Race Condition</h3></a>
<p>Let's look at a race condition. Client A sends an operation to the server,</p>
<p>Next, we need to work around the undesirable constraint each operation made by a client has to be transformed against another client's. We actually can generalize up to more than two clients—by transforming the results of the operation A x B with the results of B' &amp;mul; C, etc. But in practice, we are not going to have each operation have a corresponding and concurrent operation on each client at the same instant. Instead, we version the document, and use this to tell what operations an incoming operation should be transformed against. For instance, if operations A and B happen simultaneously, the server can do the following:</p>
<ol>
<li>Start with doc version 100.</li>
<li>Apply operation A. The doc version is now 101.</li>
<li>See that operation B says its version was set to 100. We need to bring it up to date. We store a history of all previous operations, and so we transform operation B &amp;mul; the operation to transition from version 100 → 101. The result is operation B as though it operated on version 101, which we can directly apply to our document and send out to all clients to perform.</li>
</ol>
<p>Client A becomes in sync easily:</p>
<ol>
<li>Start with doc version 100.</li>
<li>Apply operation A. Also send operation A to the server.</li>
<li>Receive an ACK from the server, and learn our version is now 101.</li>
<li>Receive operation B, which transitions from version 101 → 102; our document is now at version 102.</li>
</ol>
<p>For client B, this is somewhat tricker; we already applied our operation! So we perform a transform locally against <em>our</em> history.</p>
<ol>
<li>Start with doc verison 100.</li>
<li>Apply operation B. Also send operation B to the server. The network queue is synchronous; it only sends one operation at a time, waiting until an ACK to send the next.</li>
<li>Receive operation A, which transitions from version 100 → 101; we didn't expect this. So we transform this incoming operation A &amp;mul; operation B, for which an ACK from the server is outstanding. We result in A' (operation A if operation B had happened already) which we apply to the document. We also result in B', which we transform against to operations which have accumulated behind operation B in the network queue.</li>
<li>Receive an ACK from the server, and learn our version is now 102. Note that at this point the server state and the state of our local client are equivalent (A &amp;mul; A' == B &amp;mul; B').</li>
<li>Because we received an ACK, we can send the next operation in our network queue (if any).</li>
</ol>
<p>Note that the strategies for server and client code to bring operations &quot;up to date&quot; differ in that the client only needs to transform against one operation, while the server needs to transform against all intervening operations in its history. The server only needs to store the history up to the client that is the most out of date, however, and can always boot off clients which are off too old a version.</p>
<a class="header" href="#split-block-model" id="split-block-model"><h3>Split Block Model</h3></a>
<p>The entire document editing process is built on splitting a single origin block
element into a series of sub-elements.</p>
<p>All editing steps you can take in the frontend editor should follow this constaint.</p>
<a class="header" href="#rich-text" id="rich-text"><h1>Rich Text</h1></a>
<p>This section describes the Rich Text schema used by edit-text. This schema is
designed to be Markdown-compatible.</p>
<ol>
<li><a href="markdown.html">Markdown</a></li>
<li><a href="diary-carets.html">Carets</a></li>
</ol>
<a class="header" href="#markdown" id="markdown"><h1>Markdown</h1></a>
<p>Let's assume we have the following document in edit-text's document structure:</p>
<pre><code>DocGroup({&quot;tag&quot;: &quot;bullet&quot;}, [
    DocGroup({&quot;tag&quot;: &quot;p&quot;}, [DocChars(&quot;Item 1&quot;)]),
])
DocGroup({&quot;tag&quot;: &quot;bullet&quot;}, [
    DocGroup({&quot;tag&quot;: &quot;p&quot;}, [DocChars(&quot;Item 2&quot;)]),
])
DocGroup({&quot;tag&quot;: &quot;bullet&quot;}, [
    DocGroup({&quot;tag&quot;: &quot;p&quot;}, [DocChars(&quot;Item 3...&quot;)]),
])
</code></pre>
<p>We can trivially define a mapping from edit-text's document model to HTML. (Conversion from a doc group to HTML can be done with <code>doc_as_html</code> in <code>edit-common/lib.rs</code>. There's no inverse method.) The result is an unordered list:</p>
<pre><code>&lt;ul&gt;
  &lt;li&gt;&lt;p&gt;Item 1&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;Item 2&lt;/p&gt;&lt;/li&gt;
  &lt;li&gt;&lt;p&gt;Item 3...&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>Some conversions are straightforward: aside from all non-significant whitespace, all text nodes are converted into the DocChars(...) struct. To simplify other logic, there are some invariants that should be true about DocChars: DocChars(...) must not be empty, and there must not be two successive DocChars(...) components. This isn't validated anywhere (yet) but is expected to be true in all operations.</p>
<p>For groups, the first argument is a hashmap of <code>String</code> =&gt; <code>String</code> containing the &quot;attributes&quot;. These are similar to HTML attributes and can contain any data. The one attribute required by all groups is the &quot;tag&quot; attribute, which usually maps to the name of its HTML equivalent.</p>
<p>NOTE: The use of &quot;tag&quot; or even any HTML semantics are not required by the operational transform library, Oatie. References to the &quot;tag&quot; attribute are almost entirely contained in <code>schema.rs</code>. In theory, every document/transform schema could use its own way of distinguishing between group kinds.</p>
<p>Of interest in the above conversion is that quasi-<code>&lt;bullet&gt;</code> tag has different semantics than its HTML counterpart, <code>&lt;ul&gt;&lt;li&gt;...&lt;/li&gt;&lt;/ul&gt;</code>. This is a deliberate simplification for operational transform (that I should detail elsewhere), but essentially our goal is to better represent Markdown's semantics, not HTML's. Take the following example:</p>
<pre><code class="language-md">* Item 1
* Item 2

Interstitial paragraph

* Item 3...
</code></pre>
<p>And the middle paragraph, <code>Interstitial paragraph</code> is deleted. The document then becomes:</p>
<pre><code class="language-md">* Item 1
* Item 2
* Item 3...
</code></pre>
<p>Because edit-text converts directly from its document representation into Markdown, we can bypass the logic of joining common <code>&lt;ul&gt;</code> parents in this case and also lean more heavily on Markdown-to-html conversion to perform this for us.</p>
<a class="header" href="#markdown-serialization--deserialization" id="markdown-serialization--deserialization"><h2>Markdown serialization + deserialization</h2></a>
<p>The module that controls markdown lives at <code>edit-common/src/markdown</code>.</p>
<ul>
<li><a href="https://github.com/tcr/edit-text/blob/master/edit-common/src/markdown/ser.rs">ser.rs</a></li>
<li><a href="https://github.com/tcr/edit-text/blob/master/edit-common/src/markdown/de.rs">de.rs</a></li>
</ul>
<p>edit-text's document schema should allow conversion losslessly into Markdown, while the deserialization code takes into account (or should) that Markdown's possible output is a superset of what edit-text supports, and thus all non-supported content should be stripped out.</p>
<a class="header" href="#document-elements" id="document-elements"><h2>Document Elements</h2></a>
<p>This are the current elements supported by edit-text:</p>
<table><thead><tr><th> Tag </th><th> Description </th></tr></thead><tbody>
<tr><td> bullet </td><td> Bulleted item</td></tr>
<tr><td> p </td><td> Paragraph</td></tr>
<tr><td> h[1-6] </td><td> Header</td></tr>
<tr><td> pre </td><td> Code block</td></tr>
<tr><td> html </td><td> Inline HTML content (a raw string, as it would appear in Markdown)</td></tr>
<tr><td> caret </td><td> Caret position</td></tr>
<tr><td> hr </td><td> Horizontal rule</td></tr>
</tbody></table>
<a class="header" href="#carets" id="carets"><h1>Carets</h1></a>
<p>Carets are the vertical line which indicates your editing position in a document. When there are multiple viewers of a document, each viewer's current editing position would be represented by different carets. You can click the mouse to reposition the caret in a new location, or use various OS-specific shortcuts to move the caret by increments (like by word or line).</p>
<p>When a document is loaded, the client inserts two carets for the user: an &quot;anchor&quot; caret, and a &quot;focus&quot; caret. Usually these carets are located at the same position. When the anchor and focus carets are one more caret positions apart, the editor treats this as a selection. For example, when you click and drag your mouse to create a selection, the anchor caret stays in place and the focus caret follows your mouse.</p>
<p>Carets in edit-text are stored as part of the document itself. The data structure for carets looks like the following:</p>
<pre><code>enum Attrs {
    Caret {
        client_id: String,
        focus: boolean,
    }
    ...
}
</code></pre>
<p>The <code>client_id</code> property represents the client for whom the caret belongs. (To see your client ID, click the debug menu in the editor.) The <code>focus</code> property is <code>false</code> if this is the anchor caret, and is <code>true</code> if this is the focus caret.</p>
<p>Carets are represented as inline elements in HTML, and must exist only inside a block-level element.</p>
<p>All editing operations that delete carets must also recreate the carets (possibly in a new location) to preserve there being one anchor and one focus caret for each client at all times.</p>
<a class="header" href="#cursors" id="cursors"><h2>Cursors</h2></a>
<p>A related concept in edit-text is a cursor, represented by the <code>CurSpan</code> type, which specifies a single discrete position inside of the document (<code>DocSpan</code> type). When a user clicks their mouse, this is translated to a specific cursor inside the document. This can then be converted into a position to insert a caret (see the <code>cur_to_caret</code> function). A caret can have fewer valid positions than there are cursor positions, so this conversion is lossy.</p>
<a class="header" href="#server" id="server"><h1>Server</h1></a>
<p>The server binary serves HTTP content, a GraphQL endpoint for performing
page-level commands, and a WebSocket endpoint for synchronizing document
content.</p>
<ol>
<li><a href="server-apis.html">HTTP APIs</a></li>
<li><a href="storage.html">Storage</a></li>
</ol>
<a class="header" href="#server-apis" id="server-apis"><h1>Server APIs</h1></a>
<p>The server performs document synchronization. It is the &quot;server&quot; component that orchestrates simultaneous document modifications which happen on several Users.</p>
<table><thead><tr><th> Port </th><th> Path Mapping </th><th> Description</th></tr></thead><tbody>
<tr><td> 8000 </td><td> /    </td><td> HTML Server</td></tr>
<tr><td> 8002 </td><td> /$/ws    </td><td> WebSocket</td></tr>
<tr><td> 8003 </td><td> /$/graphql    </td><td> GraphQL</td></tr>
</tbody></table>
<p>HTML is served from <code>/</code>. Static versions of each page are available before scripting is fully downloaded.</p>
<p>When the client-side script connects the WebSocket, the server recognizes it as a new synchronization client and reloads the content of the page. Editing is then enabled. Each edit made by the client is sent to the server as an operation, and the server computes and pushes push new deltas to the client.</p>
<p>There is an additional API exposed as GraphQL for non-synchronization tasks. This exposes mutations like updating a page with Markdown, downloading and renaming pages, and other page-editing features.# Server APIs</p>
<a class="header" href="#storage" id="storage"><h1>Storage</h1></a>
<p>edit-text uses a local SQLite database for storage.</p>
<a class="header" href="#frontend" id="frontend"><h1>Frontend</h1></a>
<p>The Frontend is written in TypeScript and communicates with a WebAssembly
component containing the Client and Controller.</p>
<ol>
<li><a href="editor-component.html">Editor Component</a></li>
<li><a href="webassembly-interface.html">WebAssembly Interface</a></li>
</ol>
<a class="header" href="#editor-component" id="editor-component"><h1>Editor Component</h1></a>
<p>The frontend is written in React, and the editor is a react component.</p>
<pre><code class="language-javascript">&lt;Editor
    content={string}
    controller={ControllerImpl}
    editorID={string}
    disabled={boolean}
/&gt;
</code></pre>
<a class="header" href="#webassembly-interface" id="webassembly-interface"><h1>WebAssembly Interface</h1></a>
<p>The frontend invokes the client over a <code>wasm-bindgen</code> bridge, exchanging JSON messages (&quot;commands&quot;). The frontend exposes an editor interface using React. The client instructs the frontend on what text styling options to expose, and responds to keypresses with updated HTML to render in the editor.</p>
<a class="header" href="#deploying" id="deploying"><h1>Deploying</h1></a>
<p>This section describes how you can compile a standalone edit-server binary,
and deploy to a remote server or hosted service like Dokku.</p>
<ol>
<li><a href="edit-server-binary.html">Running as a binary</a></li>
<li><a href="dokku.html">Dokku</a></li>
<li><a href="#">Hosted Sandbox</a></li>
<li><a href="#">npm module</a></li>
</ol>
<a class="header" href="#running-as-a-binary" id="running-as-a-binary"><h1>Running as a binary</h1></a>
<p>The <code>edit-server/</code> crate can export a binary that you can deploy to a remote
server, containing the source code of the client and the ability to talk to
a locally instantiated SQLite database.</p>
<pre><code>./tools server
</code></pre>
<p>To build a standalone binary that bundles client files statically:</p>
<pre><code>cd edit-server
cargo build --release --features standalone
../target/release/edit-server
</code></pre>
<a class="header" href="#deploying-to-dokku" id="deploying-to-dokku"><h1>Deploying to Dokku</h1></a>
<p>[macOS Instructions] To deploy to a Dokku instance, you'll have to install a linux cross-compiler. This will cross-compile the Linux binary locally and then package it in a Docker container for distribution.</p>
<p>First, to install the cross compiler:</p>
<pre><code>brew install qinyao-he/homebrew-gcc_cross_compilers/x64-elf-gcc
</code></pre>
<p>Then add a new Rust target:</p>
<pre><code>rustup target add x86_64-unknown-linux-gnu
</code></pre>
<p>You can deploy edit-text to a Dokku server using <code>./tools deploy</code>.</p>
<pre><code>./tools deploy
</code></pre>
<ul>
<li>This first cross-compiles the edit-server binary using a local Docker image.</li>
<li>It then uploads the binary using the <code>dokku tar:in</code> command on a remote server (not the Git endpoint).</li>
<li>You can configure the dokku URL using the <code>EDIT_DEPLOY_URL</code> environment variable.</li>
<li>You can configure the dokku application name using the <code>EDIT_DOKKU_NAME</code> environment variable.</li>
</ul>
<a class="header" href="#appendix-1" id="appendix-1"><h1>Appendix</h1></a>
<a class="header" href="#appendix-2" id="appendix-2"><h1>Appendix</h1></a>
<a class="header" href="#appendix-3" id="appendix-3"><h1>Appendix</h1></a>
<p>Content that wasn't included in the rest of the docs.</p>
<ol>
<li><a href="diary-delall.html">Delall Hack</a></li>
<li><a href="glossary.html">Glossary</a></li>
</ol>
<a class="header" href="#delall-hack" id="delall-hack"><h1>Delall Hack</h1></a>
<p>Grepping the codebase for &quot;Delall&quot; turns up this comment in <code>transform.rs</code>:</p>
<pre><code>// &quot;Delall&quot; transform hack to avoid fully deleted elements that
// leave their content unwrapped. Because one side deletes the
// group, we can't recreate it (because we have no knowledge of
// the document). Instead, we just delete all the newly added
// content of the group.
</code></pre>
<p>This is an explainer on what this means.</p>
<a class="header" href="#operations-only-know-the-document-structure-implied-by-the-operation" id="operations-only-know-the-document-structure-implied-by-the-operation"><h2>Operations only know the document structure implied by the operation</h2></a>
<p>You do a DelGroup on a Group, but when transformed against any of these elements, we can respond consistently even without knowing the other type of document.</p>
<p>TODO: This section</p>
<ul>
<li>DelGroup x DelChars</li>
<li>DelGroup x DelWithGroup</li>
<li>DelGroup x DelGroup</li>
</ul>
<p>...</p>
<a class="header" href="#example-transform" id="example-transform"><h2>Example Transform</h2></a>
<p><strong>NOTE:</strong> This is a long, but realistic, example. Imagine every client connected that has a ton of lag, accuring operations until it waits for a server response.</p>
<p>When transforming two operations, oatie (so far) does not need to know anything about the document the operation will eventually operate on in order to compose or transform two operations. In order to maintain this property, some pedantic cases arise where we need to think carefully what the result of a transform will be.</p>
<p>Say two clients have the following document:</p>
<pre><code class="language-rust noplaypen">&lt;h1&gt;&lt;caret client=B&quot; /&gt;Hello &lt;/h1&gt;
&lt;p&gt;&lt;caret client=&quot;A&quot; /&gt; world!&lt;/p&gt;
</code></pre>
<a class="header" href="#the-journey-of-client-a" id="the-journey-of-client-a"><h3>The journey of Client A</h3></a>
<p>Client A hits backspace, which will collapse the two block-level elements (<code>h1</code> and <code>p</code>) into one. The document there will now look like this:</p>
<pre><code class="language-rust noplaypen">// This operation:
Op([
    DelGroup([DelSkip(7)]), DelGroup([DelSkip(8)]),
], [
    AddGroup({&quot;tag&quot;: &quot;h1&quot;}, [AddSkip(15)]),
])

// New Document
&lt;h1&gt;&lt;caret client=B&quot; /&gt;Hello &lt;caret client=&quot;A&quot; /&gt; world!&lt;/p&gt;
</code></pre>
<p>Next, Client A forward-deletes everything that existed in the second paragraph (<code>&quot; world!&quot;</code>). So the document now looks like this:</p>
<pre><code class="language-rust noplaypen">// This operation:
Op([
    DelWithGroup([DelSkip(8), DelChars(7)]),
], [
])

// Composed operations:
Op([
    DelGroup([DelSkip(7)]), DelGroup([DelSkip(1), DelChars(7)]),
], [
    AddGroup({&quot;tag&quot;: &quot;h1&quot;}, [AddSkip(15)]),
])

// New document
&lt;h1&gt;&lt;caret client=B&quot; /&gt;Hello &lt;caret client=&quot;A&quot; /&gt;&lt;/p&gt;
</code></pre>
<p>Lastly (for good measure) Client A clicks at the beginning of the first paragraph to move its caret:</p>
<pre><code class="language-rust noplaypen">// This operation:
Op([
    DelWithGroup([DelSkip(7), DelGroup([])]),
], [
    AddWithGroup([AddGroup({&quot;tag&quot;: &quot;caret&quot;, &quot;client&quot;: &quot;A&quot;})])
])

// Composed operations:
Op([
    DelGroup([DelSkip(7)]), DelGroup([DelGroup([]), DelChars(7)]),
], [
    AddGroup({&quot;tag&quot;: &quot;h1&quot;}, [AddGroup({&quot;tag&quot;: &quot;caret&quot;, &quot;client&quot;: &quot;A&quot;}), AddSkip(14)]),
])

// New document
&lt;h1&gt;&lt;caret client=&quot;A&quot; /&gt;&lt;caret client=B&quot; /&gt;Hello &lt;/p&gt;
</code></pre>
<a class="header" href="#the-journey-of-client-b" id="the-journey-of-client-b"><h3>The journey of Client B</h3></a>
<p>Client B is less active, has less lag, or just less to contribute. It simply moves its cursor to the second block...:</p>
<pre><code class="language-rust noplaypen">// This operation:
Op([
    DelGroup([DelGroup([]), DelSkip(7)]),
], [
    AddSkip(1), AddWithGroup([AddSkip(8), AddGroup({&quot;tag&quot;: &quot;caret&quot;, &quot;client&quot;: &quot;B&quot;}, [])]),
])

// New Document
&lt;h1&gt;Hello &lt;/h1&gt;
&lt;p&gt;&lt;caret client=&quot;A&quot; /&gt; world!&lt;caret client=B&quot; /&gt;&lt;/p&gt;
</code></pre>
<p>Then Client B hits backspace:</p>
<pre><code class="language-rust noplaypen">// This operation:
Op([
    DelSkip(1), DelWithGroup([DelSkip(7), DelChars(1)]),
], [
])

// Cumulative operation:
Op([
    DelGroup([DelGroup([]), DelSkip(7)]), DelWithGroup([DelSkip(7), DelChars(1)]),
], [
    AddSkip(1), AddWithGroup([AddSkip(8), AddGroup({&quot;tag&quot;: &quot;caret&quot;, &quot;client&quot;: &quot;B&quot;}, [])]),
])

// New Document
&lt;h1&gt;Hello &lt;/h1&gt;
&lt;p&gt;&lt;caret client=&quot;A&quot; /&gt; world&lt;caret client=B&quot; /&gt;&lt;/p&gt;
</code></pre>
<a class="header" href="#transform" id="transform"><h3>Transform</h3></a>
<p>In the end of this hypothetical, we are now transforming these two operations:</p>
<pre><code class="language-rust noplaypen">// Client A
Op([
    DelGroup([DelSkip(7)]), DelGroup([DelGroup([]), DelChars(7)]),
], [
    AddGroup({&quot;tag&quot;: &quot;h1&quot;}, [AddGroup({&quot;tag&quot;: &quot;caret&quot;, &quot;client&quot;: &quot;A&quot;}), AddSkip(14)]),
])

// Client B
Op([
    DelGroup([DelGroup([]), DelSkip(7)]), DelWithGroup([DelSkip(7), DelChars(1)]),
], [
    AddSkip(1), AddWithGroup([AddSkip(8), AddGroup({&quot;tag&quot;: &quot;caret&quot;, &quot;client&quot;: &quot;B&quot;}, [])]),
])
</code></pre>
<p>And we know exactly what each result is generated from applying each operation to our original document (first shown at the beginning of this document):</p>
<pre><code class="language-rust noplaypen">// Original document
&lt;h1&gt;&lt;caret client=B&quot; /&gt;Hello &lt;/h1&gt;
&lt;p&gt;&lt;caret client=&quot;A&quot; /&gt; world!&lt;/p&gt;


// Client A
&lt;h1&gt;&lt;caret client=&quot;A&quot; /&gt;&lt;caret client=B&quot; /&gt;Hello &lt;/p&gt;

// Client B
&lt;h1&gt;Hello &lt;/h1&gt;
&lt;p&gt;&lt;caret client=&quot;A&quot; /&gt; world&lt;caret client=B&quot; /&gt;&lt;/p&gt;
</code></pre>
<p>But when transforming, by design, we avoid needing knowledge of what the document looks like. So let's evaluate these operations as though we didn't know what the result was going to look like.</p>
<p>In particular, we want to look at how the paragraph, <code>&quot; world!&quot;</code>, is modified. Client A has deleted it entirely, whereas Client B deleted a character and inserted its caret:</p>
<pre><code>Op([DelGroup([DelGroup([]), DelChars(7)])], [])
Op([DelWithGroup([DelSkip(7), DelChars(1)])], [AddWithGroup([AddSkip(8), AddGroup({&quot;tag&quot;: &quot;caret&quot;, &quot;client&quot;: &quot;B&quot;}, [])])])
</code></pre>
<p>We can take the union of the deletions and since there is only one addition component, select it. When we transform the two, our result looks like this:</p>
<pre><code>Op([DelGroup([DelGroup([]), DelChars(7)])], [AddGroup({&quot;tag&quot;: &quot;caret&quot;, &quot;client&quot;: &quot;B&quot;}, [])])
</code></pre>
<p>If you imagine a document consisting of only this element, and we see that one client has deleted the entire element, we accidentally wind up with a client's caret being in the root element (instead of block element). See [Splitting image](./diary-markdown.md].</p>
<p>To avoid this problem, the Delall hack delets alls newly inserted elements from an insertion that is transformed against a deletion that delets all content. We can verify any arbitrary <code>DelGroup</code> delets all of its inner contents using a recursive check.</p>
<a class="header" href="#glossary" id="glossary"><h1>Glossary</h1></a>
<ul>
<li>
<p><em>client</em> — A client can connect to a server and synchronize its document
content. It sends client-side modifications (in the form of operations) to the
server, and receives updated content (in the form of operations) from the server
after any client submits an update.</p>
</li>
<li>
<p><em>controller</em> — Receives UI-level event updates from the frontend
and converts it into operations on the client document.</p>
</li>
<li>
<p><em>cursor</em> — All positions in which a Text or Group element can be
inserted into a document can be represented by a cursor object.</p>
</li>
<li>
<p><em>frontend</em> — The editor UI. The current document is rendered
as a component inside the frontend, and interactions with this component are
forwarded to the controller. The frontend also manages the toolbar,
notifications, and dialog boxes.</p>
</li>
<li>
<p><em>server</em> — Serves HTTP content, a GraphQL endpoint for performing
page-level commands, and a WebSocket endpoint for synchronizing document
content.</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
